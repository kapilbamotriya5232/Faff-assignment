import type { RealTask } from '@prisma/client'; // Import RealTask as a type
import pkg from '@prisma/client';
import fetch, { Response } from 'node-fetch'; // Import Response type for better error handling
const { PrismaClient } = pkg;

const prisma = new PrismaClient();

const API_ENDPOINT = 'http://localhost:3000/api/generative-ai'; // Adjust if your app runs on a different port
const USER_ID = 'cmb6gyp7r0000n36wbyh2x34e'; // Replace with actual User ID if dynamic
const OPERATOR_ID = 'cmb6gyppb0001n36wm4b9hql8'; // Replace with actual Operator ID if dynamic

const TASKS_PER_BATCH_FOR_API = 8; // How many tasks to send in one API call to the generative AI
const MAX_API_CALLS_PER_CYCLE = 15; // Max API calls in one 70-second cycle
const DELAY_BETWEEN_API_CALLS_MS = 1000; // 1 second delay between calls within a cycle
const CYCLE_DURATION_MS = 70000; // 70 seconds for a full cycle duration

interface ApiTaskInput {
  id: string;
  name: string;
  // description, category, and tags removed to match API endpoint
}

interface ApiMessage {
  sender: 'user' | 'operator';
  text: string;
}

interface ApiResponseTask {
  id: string;
  messages: ApiMessage[];
}

async function processSingleBatchOfTasks(tasksBatch: RealTask[]): Promise<number> {
  if (tasksBatch.length === 0) return 0;

  // Send only id and name to the API
  const apiPayload: ApiTaskInput[] = tasksBatch.map(task => ({
    id: task.id,
    name: task.name,
  }));

  let messagesCreatedInBatch = 0;

  try {
    console.log(`    [API Call] Sending ${apiPayload.length} tasks (IDs: ${tasksBatch.map(t => t.id.slice(-4)).join(', ')})...`);
    const response: Response = await fetch(API_ENDPOINT, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(apiPayload),
    });

    if (!response.ok) {
      const errorBody = await response.text();
      console.error(`    [API Call Error] For tasks (IDs: ${tasksBatch.map(t=>t.id.slice(-4)).join(', ')}), API call failed: ${response.status} ${response.statusText}. Body: ${errorBody.substring(0, 300)}...`);
      return 0; // Skip this batch on API error, cycle continues
    }

    // Type assertion for successful response
    const generatedData = await response.json() as ApiResponseTask[] | { error: string; rawOutput?: string, processedAttempt?: string, details?: string };


    if (!Array.isArray(generatedData)) { // Check if it's the error structure from the API
        if (typeof generatedData === 'object' && generatedData !== null && 'error' in generatedData) {
            console.error(`    [API Data Error] For tasks (IDs: ${tasksBatch.map(t=>t.id.slice(-4)).join(', ')}), API returned an error object: ${generatedData.error}. Details: ${generatedData.details || 'N/A'}`);
        } else {
            console.error(`    [API Data Error] For tasks (IDs: ${tasksBatch.map(t=>t.id.slice(-4)).join(', ')}), API response was not an array and not a recognized error object. Received:`, generatedData);
        }
        return 0; // Skip this batch, cycle continues
    }
    
    console.log(`    [API Success] For tasks (IDs: ${tasksBatch.map(t=>t.id.slice(-4)).join(', ')}), received responses for ${generatedData.length} tasks.`);

    for (const taskWithMessages of generatedData) {
      const originalTask = tasksBatch.find(t => t.id === taskWithMessages.id);
      if (!originalTask) {
        console.warn(`    [DB] Received messages for task ID ${taskWithMessages.id.slice(-4)} which was not in the current processed batch. Skipping.`);
        continue;
      }

      if (!taskWithMessages.messages || taskWithMessages.messages.length === 0) {
        console.log(`    [DB] No messages generated by API for RealTask ID ${originalTask.id.slice(-4)}.`);
        continue;
      }

      const messagesToCreate = taskWithMessages.messages.map(msg => ({
        content: msg.text,
        senderId: msg.sender === 'user' ? USER_ID : OPERATOR_ID,
        realTaskId: originalTask.id,
      }));

      try {
        const creationResult = await prisma.realMessage.createMany({
          data: messagesToCreate,
          skipDuplicates: true,
        });
        console.log(`    [DB] Successfully created ${creationResult.count} messages for RealTask ID: ${originalTask.id.slice(-4)}`);
        messagesCreatedInBatch += creationResult.count;
      } catch (dbError) {
        console.error(`    [DB Error] Creating messages for RealTask ID ${originalTask.id.slice(-4)}:`, dbError);
      }
    }
  } catch (error) { // Catch network errors or other issues with fetch itself
    console.error(`    [Critical Processing Error] For tasks (IDs: ${tasksBatch.map(t=>t.id.slice(-4)).join(', ')}):`, error);
    // This error is for the batch processing itself (e.g., network issue before getting a response)
    // The cycle will continue as this function will return 0.
  }
  return messagesCreatedInBatch;
}

async function populateMessages() {
  console.log('Starting script to populate RealMessages...');
  let totalMessagesCreatedOverall = 0;
  let totalTasksAttemptedOverall = 0;
  let overallCycleNumber = 0;

  while (true) {
    overallCycleNumber++;
    console.log(`\n--- Overall Cycle ${overallCycleNumber} Starting ---`);

    const cycleStartTime = Date.now();
    let callsMadeInThisCycle = 0;
    let tasksProcessedInThisCycle = 0;
    let messagesCreatedInThisCycle = 0;

    for (let i = 0; i < MAX_API_CALLS_PER_CYCLE; i++) {
      // Fetch tasks for the current small batch within the cycle
      const tasksForCurrentApiCall: RealTask[] = await prisma.realTask.findMany({
        where: { realMessages: { none: {} } }, // Only tasks that have no messages
        take: TASKS_PER_BATCH_FOR_API,
        orderBy: { createdAt: 'asc' }, 
      });

      if (tasksForCurrentApiCall.length === 0) {
        console.log('  No more RealTasks found without messages. Current cycle will end.');
        break; // No tasks left for this API call, so break from the inner loop (API calls within this cycle)
      }

      console.log(`  Cycle ${overallCycleNumber}, API Call ${callsMadeInThisCycle + 1}/${MAX_API_CALLS_PER_CYCLE}: Preparing to process ${tasksForCurrentApiCall.length} tasks.`);
      
      const messagesFromBatch = await processSingleBatchOfTasks(tasksForCurrentApiCall);
      
      callsMadeInThisCycle++; // Increment even if the batch processing had an issue, to respect MAX_API_CALLS_PER_CYCLE
      messagesCreatedInThisCycle += messagesFromBatch;
      tasksProcessedInThisCycle += tasksForCurrentApiCall.length;

      totalMessagesCreatedOverall += messagesFromBatch;
      totalTasksAttemptedOverall += tasksForCurrentApiCall.length;

      // If it's not the last call planned for this cycle, and there might be more tasks, delay.
      if (callsMadeInThisCycle < MAX_API_CALLS_PER_CYCLE) {
        const nextTasksCheck = await prisma.realTask.findMany({
            where: { realMessages: { none: {} } }, take: 1,
        });
        if (nextTasksCheck.length > 0) { // Only delay if there are more tasks to process
            console.log(`  Waiting for ${DELAY_BETWEEN_API_CALLS_MS / 1000}s before next API call in cycle...`);
            await new Promise(resolve => setTimeout(resolve, DELAY_BETWEEN_API_CALLS_MS));
        } else {
            console.log('  No more tasks available in DB for the remainder of this cycle.');
            break; // No more tasks for the cycle, break from inner loop
        }
      }
    } // End of inner loop (API calls within a cycle)

    console.log(`--- Overall Cycle ${overallCycleNumber} Summary ---`);
    console.log(`  API Calls Made in Cycle: ${callsMadeInThisCycle}`);
    console.log(`  Tasks Attempted in Cycle: ${tasksProcessedInThisCycle}`);
    console.log(`  Messages Created in Cycle: ${messagesCreatedInThisCycle}`);
    console.log(`  Overall Totals -> Messages: ${totalMessagesCreatedOverall}, Tasks Attempted: ${totalTasksAttemptedOverall}`);

    if (callsMadeInThisCycle === 0 && tasksProcessedInThisCycle === 0) { 
        // This means the very first attempt to fetch tasks in the cycle found nothing.
        console.log('No tasks found to process at the beginning of this cycle. Population likely complete.');
        break; // Break from the outer while(true) loop, ending the script.
    }
    
    const cycleEndTime = Date.now();
    const elapsedMsInCycle = cycleEndTime - cycleStartTime;
    const timeToWaitForNextCycleStart = CYCLE_DURATION_MS - elapsedMsInCycle;

    if (timeToWaitForNextCycleStart > 0) {
      console.log(`Cycle took ${elapsedMsInCycle / 1000}s. Waiting for an additional ${timeToWaitForNextCycleStart / 1000}s to complete 70s cycle duration...`);
      await new Promise(resolve => setTimeout(resolve, timeToWaitForNextCycleStart));
    } else {
      console.log(`Cycle took ${elapsedMsInCycle / 1000}s (equal or longer than 70s cycle duration). Starting next cycle immediately.`);
    }
  } // End of outer while(true) loop

  console.log('---------------------------------------------------');
  console.log(`Message population script finished.`);
  console.log(`Total messages created: ${totalMessagesCreatedOverall}`);
  console.log(`Total tasks attempted: ${totalTasksAttemptedOverall}`);
  console.log('---------------------------------------------------');
}

populateMessages()
  .catch(e => {
    console.error('Unhandled error in populateMessages script:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  }); 